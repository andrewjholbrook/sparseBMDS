Libraries
```{r}
library(MassiveMDS)
library(mvtnorm)
library(truncnorm)
```


Source functions
```{r}
source("~/sparseBMDS/code/Rscripts/sBMDS_MassiveMDS_functions.R")
#source("~/sparseBMDS/code/Rscripts/sBMDS_functions.R")
```

```{r}
set.seed(12345)
# create data
Z_ex <- rmvnorm(25, mean = rep(0, 2), sigma = diag(2))
D_ex <- as.matrix(dist(Z_ex, diag = TRUE, upper = TRUE))

# adding noise to distance matrix
noise <- matrix(rtruncnorm(25^2, mean = 0, sd = .1), 25, 25) 
noise <- (noise + t(noise)) / 2
diag(noise) <- 0
D_noise <- noise + D_ex

# create engine 
engine_test <- MassiveMDS::createEngine(embeddingDimension = 2, locationCount = 25, 
                                   truncation = TRUE, tbb = 0, simd = 0, gpu = 0, 
                                   single = 0, bandwidth = 25)
engine_test <- MassiveMDS::setPairwiseData(engine_test, data = D_ex)
#engine_test <- MassiveMDS::updateLocations(engine_test, locations = Z_ex)
engine_test <- MassiveMDS::setPrecision(engine_test, precision = 100)
```

Running simulation for Metropolis with fixed sigma
```{r}
metropolis_results <- sbmds_metropolis(maxIts = 100000, dims = 2, data = D_ex, bandwidth = 25, 
                                       precision = 100, targetAccept = 0.238, stepSize = .1)
# metropolis_results <- sbmds_metropolis_fast(dims = 2, maxIts = 100000, D = D_noise, 
#                                        sigmasq = .01, band.no = 25, targetAccept = 0.238, stepSize = .1)
```

Sanity checks for accuracy
```{r}
plot(metropolis_results[ , 1, 1], type = "l")

# traceplot when target function evaluated at thetas 
s_target_chain_mh <- c()
for (i in 1:100000){
  s_target_chain_mh[i] <- s_target_no_sigma_prior(locations = metropolis_results[i, , ], engine_test)
}

# for (i in 1:100000){
#   s_target_chain_mh[i] <- s_target_no_sigma_prior_fast(metropolis_results[i, , ], D_noise, 0.01, 25)
# }

plot(s_target_chain_mh, type = "l")
acf(s_target_chain_mh)
coda::effectiveSize(s_target_chain_mh)

# traceplot for pairwise distances
s_dist_mat_mh <- array(0, dim = c(100000, 25, 25))
for (i in 1:100000){
  s_dist_mat_mh[i, , ] <- as.matrix(dist(metropolis_results[i, , ], diag = TRUE, upper = TRUE))
}

par(mfrow=c(2,2))
for (i in 1:5){
  for (j in 1:5){
    if (i != j){
      plot(s_dist_mat_mh[-(1:20000), i, j], type = "l")
      abline(h = D_ex[i, j], col = "red")
    }
  }
}
```

Running simulation for HMC with fixed sigma
```{r}
hmc_results <- sbmds_nonadapt_sigma_hmc(maxIts = 100000, data = D_ex, 
                                        engine = engine_test, targetAccept = 0.238, stepSize = .1)
```


```{r}
plot(hmc_results[ , 1, 1], type = "l")

# traceplot when target function evaluated at thetas 
s_target_chain_hmc <- c()
for (i in 1:100000){
  s_target_chain_hmc[i] <- s_target_no_sigma_prior(locations = hmc_results[i, , ], engine_test)
}

plot(s_target_chain_hmc, type = "l")
acf(s_target_chain_hmc)
coda::effectiveSize(s_target_chain_hmc)

# traceplot for pairwise distances
s_dist_mat_hmc <- array(0, dim = c(100000, 25, 25))
for (i in 1:100000){
  s_dist_mat_hmc[i, , ] <- as.matrix(dist(hmc_results[i, , ], diag = TRUE, upper = TRUE))
}

par(mfrow=c(2,2))
for (i in 1:25){
  for (j in 1:25){
    if (i != j){
      plot(s_dist_mat_hmc[, i, j], type = "l")
      abline(h = D_ex[i, j], col = "red")
    }
  }
}
```

Capturing MSE as a function of band # with fixed sigma = 0.01 & cmds as initial position 

```{r}
set.seed(12345)
samp <- c(25, 50)#c(10, 15, 20, 25, 30)
mse_band2 <- matrix(NA, nrow = max(samp), ncol = length(samp))

for (r in 1:length(samp)){
  n <- samp[r]
  Z.sim <- mvtnorm::rmvnorm(n, mean = rep(0, 2), sigma = diag(2)) # dims = 2, n = 25
  D.sim <- as.matrix(dist(Z.sim, diag = TRUE, upper = TRUE)) # n x n matrix of distances
  noise <- matrix(rtruncnorm(n^2, mean = 0, sd = .1), n, n) 
  noise <- (noise + t(noise)) / 2
  diag(noise) <- 0
  D.noise <- noise + D.sim
  for (s in 1:n){
    engine.sim <- MassiveMDS::createEngine(embeddingDimension = 2, locationCount = n,
                                         truncation = TRUE, tbb = 0, simd = 0, gpu = 0,
                                         single = 0, bandwidth = s)
    engine.sim <- MassiveMDS::setPairwiseData(engine_test, data = D.noise)
    engine.sim <- MassiveMDS::updateLocations(engine_test, locations = Z.sim)
    engine.sim <- MassiveMDS::setPrecision(engine_test, precision = 100)
    # sim <- sbmds_metropolis_fast(dims = 2, maxIts = 100000, band.no = s, targetAccept = 0.238,
    #                              sigmasq = .01, D = D.noise, stepSize = 1)
    sim <- sbmds_metropolis(maxIts = 100000, data = D.noise, engine = engine.sim, targetAccept = 0.238,
                            stepSize = .1)
    error <- c()
    for (t in 1:100000){
      error[t] <- mean((as.matrix(dist(sim[t, , ], diag = TRUE, upper = TRUE)) - D.noise)^2)
    }
    mse_band2[s, r] <- mean(error)
  }
}
```
```{r}
plot(mse_band2[, 1])
```

