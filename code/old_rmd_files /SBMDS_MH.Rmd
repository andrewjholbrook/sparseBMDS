---
title: "Sparse BMDS Log-likelihood for Metropolis-Hasti"
author: "Ami Sheth"
date: "2022-09-08"
output: html_document
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(Matrix)
library(mvtnorm)
library(MASS)
library(invgamma)
library(truncnorm)
library(tidyverse)
library(gridExtra)
```

## Simulation data

```{r}
set.seed(12345)
Z_ex <- mvrnorm(25, mu = c(0,0), Sigma = diag(c(1, 1)))
Z_tilde <- mvrnorm(25, mu = c(0,0), Sigma = diag(c(1, 1))) + 0.1
D_ex <- as.matrix(dist(Z_ex, diag = TRUE, upper = TRUE))
D_latent <- as.matrix(dist(Z_tilde, diag = TRUE, upper = TRUE))
```

```{r}
n <- dim(D_ex)[1]
band <- matrix(NA, nrow = n - 1, ncol = 3)
for (i in 1: n - 1){
  band[i, 1] <- D_ex[i, i + 1]
  if (i < n - 1){
    band[i, 2] <- D_ex[i, i + 2]
  }
  if (i < n - 2){
    band[i, 3] <- D_ex[i, i + 3]
  }
}
band
```

```{r}
n <- dim(D_ex)[1]
band.no <- 25
band_latent <- matrix(NA, nrow = n - 1, ncol = band.no)
band_obs <- matrix(NA, nrow = n - 1, ncol = band.no)
pad <- matrix(NA, nrow = n, ncol = band.no)
D_latent_pad <- cbind(D_latent, pad)
D_pad <- cbind(D_ex, pad)
  
for (i in 1:(n - 1)){
  band_latent[i, ] <- D_latent_pad[i, i + 1:band.no]
  band_obs[i, ] <- D_pad[i, i + 1:band.no]
}

sum((band_obs - band_latent)^2, na.rm = TRUE) / (2 * 0.3) #+ 
#sum(log(pnorm(band_latent / sqrt(0.3))), na.rm = TRUE)
```


```{r}
n <- dim(D_ex)[1]
bands <- 25
band_lat <- matrix(NA, nrow = bands  , ncol = n)
band_oup <- matrix(NA, nrow = bands  , ncol = n)

pad <- matrix(NA, nrow = bands, ncol = n)
band_pad <- rbind(pad, D_latent)
obs_pad <- rbind(pad, D_ex)

for (i in 1 : n){
  band_lat[, i] <- band_pad[i + bands - bands:1, i]
  band_oup[, i] <- obs_pad[i + bands - bands:1, i]
}

band_lat
#sum((band_oup - band_lat)^2, na.rm = TRUE) / (2 * 0.3) #+ 
#sum(log(pnorm(band_lat / sqrt(0.3))), na.rm = TRUE)
```

## Sparse log-likelihood

1. if-statement method

```{r}
# sum_r <- function(D_latent, D, sigma){
#   n <- dim(D)[1]
#   band_latent <- matrix(NA, nrow = n - 1, ncol = 3)
#   band_obs <- matrix(NA, nrow = n - 1, ncol = 3)
#   
#   for (i in 1:(n - 1)){
#     band_latent[i, 1] <- D_latent[i, i + 1]
#     band_obs[i, 1] <- D[i, i + 1]
#     if (i < n - 1){
#       band_latent[i, 2] <- D_latent[i, i + 2]
#       band_obs[i, 2] <- D[i, i + 2]
#       }
#     if (i < n - 2){
#       band_latent[i, 3] <- D_latent[i, i + 3]
#       band_obs[i, 3] <- D[i, i + 3]
#     }
#   }
#   
#   SSR_val = (band_obs - band_latent)^2
#   stat = band_latent / sqrt(sigma)
#   logsum = log(pnorm(stat))
#   r = sum(SSR_val/(2 * sigma) + logsum, na.rm = TRUE)
#   return(r)
# }
```

2. padded with NAs, function of number of bands - vectorized 

```{r}
sum_r <- function(D_latent, D, sigma, band.no){
  #D_latent <- as.matrix(dist(latent, diag = TRUE, upper = TRUE))
  n <- dim(D)[1]
  band_latent <- matrix(NA, nrow = n - 1, ncol = band.no)
  band_obs <- matrix(NA, nrow = n - 1, ncol = band.no)
  pad <- matrix(NA, nrow = n, ncol = band.no)
  D_latent_pad <- cbind(D_latent, pad)
  D_pad <- cbind(D, pad)

  for (i in 1:(n - 1)){
    band_latent[i, ] <- D_latent_pad[i, i + 1:band.no]
    band_obs[i, ] <- D_pad[i, i + 1:band.no]
  }

  SSR_val = (band_obs - band_latent)^2
  stat = band_latent / sqrt(sigma)
  logsum = log(pnorm(stat))
  r = sum(SSR_val/(2 * sigma), logsum, na.rm = TRUE)
  return(r)
}
```

3. function of the number of bands, coded with two for loops

```{r}
sum_r2 <- function(D_latent, D, sigma, band.no){
  n <- dim(D)[1]
  SSR_val = 0
  logsum = 0
  pad <- matrix(NA, nrow = n, ncol = band.no)
  D_latent_pad <- cbind(D_latent, pad)
  D_pad <- cbind(D, pad)
  
  for (i in 1:n){
    for (j in 1:band.no){
      SSR_val = sum(SSR_val, (D_pad[i, i + j] - D_latent_pad[i, i + j])^2, na.rm = TRUE)
      stat = D_latent_pad[i, i + j] / sqrt(sigma)
      logsum = sum(logsum, log(pnorm(stat)), na.rm = TRUE)
    }
  }
  r = SSR_val/(2 * sigma) + logsum
  return(r)
}
```

```{r}
s_bmds_ll <- function(sigma, D, latent, band.no){ 
  # latent variables (nxk), observed distance matrix D (nxn), sigma^2
  D_latent <- as.matrix(dist(latent, diag = TRUE, upper = TRUE))
  n <- dim(D_latent)[1]
  m <- n * band.no - band.no * (band.no + 1) / 2  
  term1 <- (m / 2) * log(sigma)
  term2 <- sum_r(D_latent, D, sigma, band.no)
  loglik <- -(term1 + term2 + m/2 * log(2 * pi))
  return(loglik)
}

s_bmds_ll2 <- function(sigma, D, latent, band.no){ 
  # latent variables (nxk), observed distance matrix D (nxn), sigma^2
  D_latent <- as.matrix(dist(latent, diag = TRUE, upper = TRUE))
  n <- dim(D_latent)[1]
  m <- n * band.no - band.no * (band.no + 1) / 2  
  term1 <- (m / 2) * log(sigma)
  term2 <- sum_r2(D_latent, D, sigma, band.no)
  loglik <- -(term1 + term2)
  return(loglik)
}
```

#### sanity check 

```{r}
set.seed(12345)
Z_ex <- mvrnorm(200, mu = c(0,0), Sigma = diag(c(1, 1)))
#Z_tilde <- mvrnorm(25, mu = c(0,0), Sigma = diag(c(1, 1))) + 0.1
D_ex <- as.matrix(dist(Z_ex, diag = TRUE, upper = TRUE))

t <- proc.time()
ll_latent(sigma = 0.3, D_ex, latent = Z_ex)
proc.time() - t
#ll_latent(sigma = 0.3, D_ex, latent = Z_tilde)

t <- proc.time()
s_bmds_ll(sigma = 0.3, D_ex, latent = Z_ex, band.no = 200)
proc.time() - t
#s_bmds_ll(sigma = 0.3, D_ex, latent = Z_tilde, band.no = 25)

t <- proc.time()
s_bmds_ll2(sigma = 0.3, D_ex, latent = Z_ex, band.no = 200)
proc.time() - t
#s_bmds_ll2(sigma = 0.3, D_ex, latent = Z_tilde, band.no = 25)
```

## M-H with sparse likelihood

1. adaptive theta

```{r}
# target function is the log-posterior which is proportional to log-likelihood + log-priors
s_target <- function(theta, D, sigma, band.no) { # theta the latent variable; dims x 1 vector
  output <- s_bmds_ll(sigma, D, latent = theta, band.no) + 
    sum(mvtnorm::dmvnorm(theta, log = TRUE)) # independent, standard Gaussian prior for theta
  return(output)
}

delta <- function(n) {
  return( min(0.01, n^(-0.5)) )
}

s_adapt_metropolis <- function(dims, maxIts, D, sigma, band.no,
                               targetAccept = 0.8, 
                               stepSize = 1) {
  
  # create the chain 
  n <- dim(D)[1]
  chain <- array(0, dim = c(maxIts, n, dims))
  
  # specify the first random value
  chain[1, , ] <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(dims))
  
  totalAccept <- rep(0, maxIts)
  Acceptances = 0 # total acceptances within adaptation run (<= SampBound)
  SampBound = 50   # current total samples before adapting radius
  SampCount = 0   # number of samples collected (adapt when = SampBound)
  
  for (s in 2:maxIts) {
    
    thetaStar <- cbind(rnorm(n, mean = chain[s - 1, , 1], sd = stepSize), 
                       rnorm(n, mean = chain[s - 1, , 2], sd = stepSize))
    # smaller proposal variance = more acceptances 
    # proposal: normal dist
    u <- runif(1)
    # Metropolis, A = target(thetaStar)/target(previous iteration)
    logA <- s_target(thetaStar, D) - 
      s_target(chain[s - 1, , ], D) # target on log scale
    
    if(log(u) < logA) {
      chain[s, , ] <- thetaStar # ACCEPT !! # next iteration to thetastar
      totalAccept[s] <- 1
      Acceptances = Acceptances + 1 # acceptance counter
    } else {
      chain[s, , ] <- chain[s - 1, , ] # REJECT !! # next iteration stays at same iteration
    }
    
    SampCount <- SampCount + 1
    
    # tune
    if (SampCount == SampBound) { 
      AcceptRatio <- Acceptances / SampBound
      if (AcceptRatio > targetAccept) {
        stepSize <- stepSize * (1 + delta(s - 1)) # increase stepsize 
      } else {
        stepSize <- stepSize * (1 - delta(s - 1)) # decrease stepsize
      }
      
      # reset Sampcount and Acceptances
      SampCount <- 0
      Acceptances <- 0
    }
    
    if (s %% 100 == 0) cat("Iteration ", s, "\n","stepSize: ", stepSize, "\n") 
  }
  
  cat("Acceptance rate: ", sum(totalAccept)/(maxIts - 1))
  
  return(chain)
}
```

```{r}
set.seed(12345)
maxIts <- 100000
dims <- 2
n <- 25
Z <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
D.1 <- as.matrix(dist(Z, diag = TRUE, upper = TRUE)) # n x n matrix of distances

s_adapt_results <- s_adapt_metropolis(dims, maxIts, D = D.1, targetAccept = 0.65, 
                                      stepSize = 1)
```

2. adaptive sigma and theta
```{r}
# target function is the log-posterior which is proportional to log-likelihood + log-priors
s_target2 <- function(sigma, theta, band.no, D) { # theta the latent variable; dims x 1 vector
  output <- s_bmds_ll2(sigma, D, latent = theta, band.no) + 
    sum(mvtnorm::dmvnorm(theta, log = TRUE)) + # independent, standard Gaussian prior for theta
    dinvgamma(sigma, shape = 1, rate = 1, log = TRUE) # inverse-gamma prior for sigma
  return(output)
}

delta <- function(n) {
  return( min(0.01, n^(-0.5)) )
}

s_adapt_metropolis2 <- function(dims, maxIts, D, band.no = 3,
                              targetAccept = 0.8, targetAccept_Sigma = 0.8, 
                              stepSize = 1, stepSizeSigma = 1) {
  
  # create the chain 
  n <- dim(D)[1]
  chain <- array(0, dim = c(maxIts, n, dims)) # matrix(0, maxIts, D) 
  sigma_chain <- rep(0, maxIts)
  
  # specify the first random value
  chain[1, , ] <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(dims))
  sigma_chain[1] <- 1 # runif(1, min = 0.01, max = 0.99) # pick large number 
  
  totalAccept <- rep(0, maxIts)
  totalAccept_Sigma <- rep(0, maxIts)
  Acceptances = 0 # total acceptances within adaptation run (<= SampBound)
  Acceptances_Sigma = 0
  SampBound = 50   # current total samples before adapting radius
  SampCount = 0   # number of samples collected (adapt when = SampBound)
  SampCount_Sigma = 0
  
  for (s in 2:maxIts) {
    
    thetaStar <- cbind(rnorm(n, mean = chain[s - 1, , 1], sd = stepSize), 
                       rnorm(n, mean = chain[s - 1, , 2], sd = stepSize))
    # smaller proposal variance = more acceptances 
    # proposal: normal dist
    u <- runif(1)
    # Metropolis, A = target(thetaStar)/target(previous iteration)
    logA <- s_target2(sigma_chain[s - 1], thetaStar, band.no, D) - 
      s_target2(sigma_chain[s - 1], chain[s - 1, , ], band.no, D) # target on log scale
    
    if(log(u) < logA) {
      chain[s, , ] <- thetaStar # ACCEPT !! # next iteration to thetastar
      totalAccept[s] <- 1
      Acceptances = Acceptances + 1 # acceptance counter
    } else {
      chain[s, , ] <- chain[s - 1, , ] # REJECT !! # next iteration stays at same iteration
    }
    
    # proposal distribution for sigma
    sigmaStar <- rtruncnorm(1, a = 0, b = Inf, mean = sigma_chain[s - 1], sd = stepSizeSigma) 
    
    # Metropolis, A2 = target(sigmaStar)/target(previous iteration)
    # comparing new and old sigma with current chain, no longer symmetric proposal 
    logA2 <- s_target2(sigmaStar, chain[s, , ], band.no, D) - 
      s_target2(sigma_chain[s - 1], chain[s, , ], band.no, D) + 
      log(truncnorm::dtruncnorm(x = sigma_chain[s - 1], a = 0, 
                                    mean = sigmaStar, sd = stepSizeSigma)) - 
      log(truncnorm::dtruncnorm(x = sigmaStar, a = 0, 
                                    mean = sigma_chain[s - 1], sd = stepSizeSigma)) 
    
    u2 <- runif(1)
    if(log(u2) < logA2) {
      sigma_chain[s] <- sigmaStar
      totalAccept_Sigma[s] <- 1
      Acceptances_Sigma <- Acceptances_Sigma + 1
    } else {
      sigma_chain[s] <- sigma_chain[s - 1]
    }
    
    SampCount <- SampCount + 1
    SampCount_Sigma <- SampCount_Sigma + 1
    
    # tune
    if (SampCount == SampBound) { 
      AcceptRatio <- Acceptances / SampBound
      if ( AcceptRatio > targetAccept ) {
        stepSize <- stepSize * (1 + delta(s - 1)) # increase stepsize 
      } else {
        stepSize <- stepSize * (1 - delta(s - 1)) # decrease stepsize
      }
      
      # reset Sampcount and Acceptances
      SampCount <- 0
      Acceptances <- 0
    }
    
    if (SampCount_Sigma == SampBound) { 
      AcceptRatio_Sigma <- Acceptances_Sigma / SampBound
      if (AcceptRatio_Sigma > targetAccept_Sigma) {
        stepSizeSigma <- stepSizeSigma * (1 + delta(s - 1)) # increase stepsize 
      } else {
        stepSizeSigma <- stepSizeSigma * (1 - delta(s - 1)) # decrease stepsize
      }
      
      # reset Sampcount and Acceptances
      SampCount_Sigma <- 0
      Acceptances_Sigma <- 0
    }
    
    if (s %% 100 == 0) cat("Iteration ", s, "\n","stepSize: ", stepSize, "\n",
                           "stepSizeSigma: ", stepSizeSigma, "\n") 
  }
  
  cat("Acceptance rate: ", sum(totalAccept)/(maxIts - 1), 
      "Acceptance rate for sigma: ", sum(totalAccept_Sigma)/(maxIts - 1))
  
  return(list(sigma_chain, chain))
}
```

```{r}
set.seed(12345)
#maxIts <- 1000
#dims <- 2
#n <- 200
Z <- mvtnorm::rmvnorm(25, mean = rep(0, 2), sigma = diag(c(1, 1))) # dims = 2, n = 25
D.1 <- as.matrix(dist(Z, diag = TRUE, upper = TRUE)) # n x n matrix of distances
band_opt <- c(25)#c(5, 10, 50, 100, 150, 200)
timesmh <- c()

for (i in 1:length(band_opt)){
  stimesmh <- proc.time()
  s_adapt_results2 <- s_adapt_metropolis2(dims = 2, maxIts = 100000, band.no = band_opt[i], D = D.1, 
                                        targetAccept = 0.65, 
                                        targetAccept_Sigma = 0.5,
                                        stepSize = 1, stepSizeSigma = 1)
  time <- proc.time() - stimesmh
  timesmh[i] <- time[3]
}
 
timesmh
```

1. graphs for (1)

```{r}
burnin <- 30000
plot(s_adapt_results[-(1:burnin), 1, 1], type = "l") # first latent variable, first dimension

# traceplot when target function evaluated at thetas 
s_target_chain_mh <- c()
for (i in 1:maxIts){
  s_target_chain_mh[i] <- s_target(s_adapt_results[i, , ], D = D.1)
}

plot(s_target_chain_mh[-(1:burnin)], type = "l")
#abline(h = target(Z), col = "red")
plot(density(s_target_chain_mh[-(1:burnin)])) 
acf(s_target_chain_mh[-(1:burnin)])
coda::effectiveSize(s_target_chain_mh[-(1:burnin)])

# traceplot for pairwise distances
s_dist_mat_mh <- array(0, dim = c(maxIts, 25, 25))
for (i in 1:maxIts){
  s_dist_mat_mh[i, , ] <- as.matrix(dist(s_adapt_results[i, , ], diag = TRUE, upper = TRUE))
}

par(mfrow=c(2,2))
plot(s_dist_mat_mh[-(1:burnin), 1, 2], type = "l")
abline(h = D.1[1, 2], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 3], type = "l")
abline(h = D.1[1, 3], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 4], type = "l")
abline(h = D.1[1, 4], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 5], type = "l")
abline(h = D.1[1, 5], col = "red")

plot(s_dist_mat_mh[-(1:burnin), 1, 6], type = "l")
abline(h = D.1[1, 6], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 7], type = "l")
abline(h = D.1[1, 7], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 8], type = "l")
abline(h = D.1[1, 8], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 9], type = "l")
abline(h = D.1[1, 9], col = "red")

par(mfrow=c(2,2))
plot(s_dist_mat_mh[-(1:burnin), 2, 1], type = "l")
abline(h = D.1[2, 1], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 3], type = "l")
abline(h = D.1[2, 3], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 4], type = "l")
abline(h = D.1[2, 4], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 5], type = "l")
abline(h = D.1[2, 5], col = "red")

plot(s_dist_mat_mh[-(1:burnin), 2, 6], type = "l")
abline(h = D.1[2, 6], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 7], type = "l")
abline(h = D.1[2, 7], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 8], type = "l")
abline(h = D.1[2, 8], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 9], type = "l")
abline(h = D.1[2, 9], col = "red")


plot(s_dist_mat_mh[-(1:burnin), 2, 10], type = "l")
abline(h = D.1[2, 10], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 25, 5], type = "l")
abline(h = D.1[25, 5], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 15, 7], type = "l")
abline(h = D.1[15, 7], col = "red") # more off than the others

par(mfrow=c(2,2))
acf(s_dist_mat_mh[-(1:burnin), 1, 2])
acf(s_dist_mat_mh[-(1:burnin), 2, 10])
acf(s_dist_mat_mh[-(1:burnin), 25, 5])
acf(s_dist_mat_mh[-(1:burnin), 15, 7])

par(mfrow=c(2,2))
plot(density(s_dist_mat_mh[-(1:burnin), 1, 2]))
plot(density(s_dist_mat_mh[-(1:burnin), 2, 10]))
plot(density(s_dist_mat_mh[-(1:burnin), 25, 5]))
plot(density(s_dist_mat_mh[-(1:burnin), 15, 7]))

coda::effectiveSize(s_dist_mat_mh[-(1:burnin), 1:25, 10])
```

2. graphs for (2)
```{r}
maxIts <- 100000
burnin <- 30000
plot(s_adapt_results2[[2]][-(1:burnin), 1, 1], type = "l") # first latent variable, first dimension
plot(s_adapt_results2[[1]][-(1:burnin)], type = "l") # sigmas

# traceplot when target function evaluated at thetas 
s_target_chain_mh2 <- c()
for (i in 1:maxIts){
  s_target_chain_mh2[i] <- s_target2(s_adapt_results2[[1]][i], s_adapt_results2[[2]][i, , ], 
                                     band.no = 25, D = D.1)
}

plot(s_target_chain_mh2[-(1:burnin)], type = "l")
#abline(h = target(Z), col = "red")
plot(density(s_target_chain_mh2[-(1:burnin)])) 
acf(s_target_chain_mh2[-(1:burnin)])
coda::effectiveSize(s_target_chain_mh2[-(1:burnin)])

# traceplot for pairwise distances
s_dist_mat_mh2 <- array(0, dim = c(maxIts, 25, 25))
for (i in 1:maxIts){
  s_dist_mat_mh2[i, , ] <- as.matrix(dist(s_adapt_results2[[2]][i, , ], diag = TRUE, upper = TRUE))
}
```

comparing across distances

```{r}
par(mfrow=c(2,2))
for (z in 1:25){
  for (y in 1:z){
    if (y != z){
    plot(s_dist_mat_mh2[-(1:burnin), z, y], type = "l", ylab = paste("Distance", z, "with", y))
    abline(h = D.1[z, y], col = "red")
    }
  }
}
```

## capture MSE as a function of the number of bands

```{r}
set.seed(12345)
maxIts <- 100000
burnin <- 30000
dims <- 2
samp <- c(10, 15, 20, 25, 30)

mse_band <- matrix(NA, nrow = max(samp), ncol = length(samp))
for (r in 1:length(samp)){
  n <- samp[r]
  Z.sim <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
  D.sim <- as.matrix(dist(Z.sim, diag = TRUE, upper = TRUE)) # n x n matrix of distances
  for (s in 1:n){
    sim <- s_adapt_metropolis2(dims, maxIts, band.no = s, D = D.sim, targetAccept = 0.65,
                               targetAccept_Sigma = 0.5, stepSize = 1, stepSizeSigma = 1)
    error <- c()
    for (t in 1:maxIts){
      error[t] <- mean((as.matrix(dist(sim[[2]][t, , ], diag = TRUE, upper = TRUE)) - D.sim)^2)
    }
    mse_band[s, r] <- mean(error[-(1:burnin)])
  }
}
```

```{r}
for (r in 1:length(samp)){
  plot(mse_band[, r], ylab = "Mean Squared Error", xlab = "Band Number", 
       main = paste("Band Selection ( n = ", samp[r], ")"), 
       xlim = c(0, samp[r]))
}
```
```{r}
mse_band
```

### adding noise to observed distance matrix - error added to each element in distance matrix 

```{r}
set.seed(12345)
maxIts <- 100000
burnin <- 30000
dims <- 2
samp <- c(10, 15, 20, 25, 30)

#mse_band <- array(0, dim = c(samp, 2)) # row, column, number of the matrix
mse_band2 <- matrix(NA, nrow = max(samp), ncol = length(samp))
sigma.sim2 <- matrix(NA, nrow = max(samp), ncol = length(samp))
for (r in 1:length(samp)){
  n <- samp[r]
  Z.sim <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
  D.sim <- as.matrix(dist(Z.sim, diag = TRUE, upper = TRUE)) # n x n matrix of distances
  #noise <- matrix(rexp(n^2, rate = 1), n, n) # mean = 1 # increasing magnitude of noise
  noise <- matrix(rtruncnorm(n^2, mean = 0, sd = 2), n, n) 
  noise <- (noise + t(noise)) / 2
  diag(noise) <- 0
  D.noise <- noise + D.sim
  for (s in 1:n){
    sim <- s_adapt_metropolis2(dims, maxIts, band.no = s, targetAccept = 0.65, D = D.noise,
                               targetAccept_Sigma = 0.5, stepSize = 1, stepSizeSigma = 1)
    error <- c()
    for (t in 1:maxIts){
      error[t] <- mean((as.matrix(dist(sim[[2]][t, , ], diag = TRUE, upper = TRUE)) - D.noise)^2)
    }
    mse_band2[s, r] <- mean(error[-(1:burnin)])
    sigma.sim2[s, r] <- mean(sim[[1]][-(1:burnin)]) # try mode next time
  }
}
```

```{r}
for (r in 1:length(samp)){
  plot(mse_band2[, r], ylab = "Mean Squared Error", xlab = "Band Number", 
       main = paste("Band Selection with noise ( n = ", samp[r], ")"), 
       xlim = c(0, samp[r]))
}
```

conclusion need more bands when adding error 

```{r}
for (r in 1:length(samp)){
  plot(sigma.sim2[, r], ylab = "Posterior Mean of Sigma", xlab = "Band Number", 
       main = paste("Band Selection with noise ( n = ", samp[r], ")"), 
       xlim = c(0, samp[r]))
}

sigma.sim2
```

```{r}
set.seed(12345)
maxIts <- 100000
dims <- 2
n <- 25
Z <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
D.1 <- as.matrix(dist(Z, diag = TRUE, upper = TRUE)) # n x n matrix of distances
noise <- matrix(rtruncnorm(n^2, mean = 0, sd = 3), n, n) 
# increasing magnitude of noise
noise <- (noise + t(noise)) / 2
diag(noise) <- 0
D.noise <- noise + D.1

s_adapt_results3 <- s_adapt_metropolis2(dims, maxIts, band.no = 25, D = D.noise, 
                                        targetAccept = 0.65, 
                                        targetAccept_Sigma = 0.5,
                                        stepSize = 1, stepSizeSigma = 1)
```

```{r}
plot(s_adapt_results3[[1]][-(1:30000)], type = "l")
quantile(s_adapt_results3[[1]][-(1:30000)], probs = .025)  # posterior mean = 0.428
quantile(s_adapt_results3[[1]][-(1:30000)], probs = .975)
coda::effectiveSize(s_adapt_results3[[1]][-(1:30000)])
```

### error graph

```{r}
sig_error <- function(noise){
  sig <- log(1 + noise/100)
  return(sqrt(sig))
}

# pct needs to be a vector
sim_errorpct <- function(pct, dims, size, maxIts, band.no, targetAccept, data,
                         targetAccept_Sigma, stepSize, stepSizeSigma){
  data_sim <- array(0, dim = c(length(pct), size, dims))
  for (i in 1:length(pct)){
    noise <- matrix(exp(rnorm(size^2, mean = 0, sd = sig_error(noise = pct[i]))), size, size)
    noise <- (noise + t(noise)) / 2
    diag(noise) <- 0
    D.noise <- noise * data
    sim <- s_adapt_metropolis2(dims, maxIts, band.no, targetAccept, D = D.noise,
                                  targetAccept_Sigma, stepSize, stepSizeSigma)
  
    data_sim[i, , ] <- sim[[2]][maxIts, , ]
  }
  return(data_sim)
}
```

data simulation
```{r}
set.seed(12345)

l <- rep(c("blue", "green", "yellow", "orange", "red"), 5)

data_test <- tibble(x = rep(seq(-1, 1, by = .5), 5),
                    y = c(rep(-1, 5), rep(-.5, 5), rep(0, 5), rep(.5, 5), rep(1, 5)),
                    color = l)
dist_test <- as.matrix(dist(data_test[, 1:2], diag = TRUE, upper = TRUE))

# permuting items of the data
data_test2 <- data_test[sample(nrow(data_test)), ]
dist_test2 <- as.matrix(dist(data_test2[, 1:2], diag = TRUE, upper = TRUE))

#dist_test2 <- dist_test[sample(nrow(dist_test)), sample(ncol(dist_test))]

# data_test - both datasets yield the same grid (as expected)
ggplot(data = data_test, aes(x, y, color = color)) +
  geom_point() + theme(legend.position = "none")

ggplot(data = data_test2, aes(x, y, color = color)) +
  geom_point() + theme(legend.position = "none")
```

```{r}
set.seed(12345)
noise_pct <- c(0, 2, 5, 10)
sim_band25 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 25, 
                           targetAccept = 0.65, data = dist_test2, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
set.seed(12345)
sim_band10 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 10, 
                           targetAccept = 0.65, data = dist_test2, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
# set.seed(12345)
# sim_band9 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
#                            maxIts = 100000, band.no = 9, 
#                            targetAccept = 0.65, data = dist_test, 
#                            targetAccept_Sigma = 0.5, stepSize = 1, 
#                            stepSizeSigma = 1)
```

```{r}
set.seed(12345)
sim_band8 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 8, 
                           targetAccept = 0.65, data = dist_test2, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
set.seed(12345)
sim_band6 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 6, 
                           targetAccept = 0.65, data = dist_test2, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
set.seed(12345)
sim_band3 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 3, 
                           targetAccept = 0.65, data = dist_test2, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
theme_update(plot.title = element_text(hjust = 0.5, size = rel(.75)),
             legend.position = "none")

# 25 bands 
g1.25 <- ggplot(data = tibble(x.sim = sim_band25[1, , 1], y.sim = sim_band25[1, , 2],
                              color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("25 bands \n", noise_pct[1], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
  #coord_fixed(ratio = 1, xlim = c(-1.5, 2), ylim = c(-1.5, 1.5))

g2.25 <- ggplot(data = tibble(x.sim = sim_band25[2, , 1], y.sim = sim_band25[2, , 2],
                              color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("25 bands \n", noise_pct[2], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
# coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.75, 1.5))

g3.25 <- ggplot(data = tibble(x.sim = sim_band25[3, , 1], y.sim = sim_band25[3, , 2],
                              color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("25 bands \n", noise_pct[3], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

g4.25 <- ggplot(data = tibble(x.sim = sim_band25[4, , 1], y.sim = sim_band25[4, , 2],
                              color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("25 bands \n", noise_pct[4], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

# 10 bands

g1.10 <- ggplot(data = tibble(x.sim = sim_band10[1, , 1], y.sim = sim_band10[1, , 2],
                              color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
    labs(title = paste("10 bands \n", noise_pct[1], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

g2.10 <- ggplot(data = tibble(x.sim = sim_band10[2, , 1], y.sim = sim_band10[2, , 2],
                              color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("10 bands \n", noise_pct[2], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

g3.10 <- ggplot(data = tibble(x.sim = sim_band10[3, , 1], y.sim = sim_band10[3, , 2],
                              color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("10 bands \n", noise_pct[3], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

g4.10 <- ggplot(data = tibble(x.sim = sim_band10[4, , 1], y.sim = sim_band10[4, , 2],
                              color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("10 bands \n", noise_pct[4], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

# 9 bands

# g1.9 <- ggplot(data = tibble(x.sim = sim_band9[1, , 1], y.sim = sim_band9[1, , 2])) + 
#   geom_point(aes(x.sim, y.sim), color = color) + 
#     labs(title = paste("9 bands \n", noise_pct[1], "% noise"),
#          x = "",
#          y = "") + 
#   coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
#   #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
# 
# g2.9 <- ggplot(data = tibble(x.sim = sim_band9[2, , 1], y.sim = sim_band9[2, , 2])) + 
#   geom_point(aes(x.sim, y.sim), color = color) + 
#   labs(title = paste("9 bands \n", noise_pct[2], "% noise"),
#          x = "",
#          y = "") + 
#   #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
#   coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
# 
# 
# g3.9 <- ggplot(data = tibble(x.sim = sim_band9[3, , 1], y.sim = sim_band9[3, , 2])) + 
#   geom_point(aes(x.sim, y.sim), color = color) + 
#   labs(title = paste("9 bands \n", noise_pct[3], "% noise"),
#          x = "",
#          y = "") + 
#   #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
#   coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
# 
# 
# g4.9 <- ggplot(data = tibble(x.sim = sim_band9[4, , 1], y.sim = sim_band9[4, , 2])) + 
#   geom_point(aes(x.sim, y.sim), color = color) + 
#   labs(title = paste("9 bands \n", noise_pct[4], "% noise"),
#          x = "",
#          y = "") + 
#   #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
#   coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

# 8 bands

# g1.8 <- ggplot(data = tibble(x.sim = sim_band8[1, , 1], y.sim = sim_band8[1, , 2])) + 
#   geom_point(aes(x.sim, y.sim), color = color) + 
#     labs(title = paste("8 bands \n", noise_pct[1], "% noise"),
#          x = "",
#          y = "") + 
#   coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
#   #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
# 
# g2.8 <- ggplot(data = tibble(x.sim = sim_band8[2, , 1], y.sim = sim_band8[2, , 2])) + 
#   geom_point(aes(x.sim, y.sim), color = color) + 
#   labs(title = paste("8 bands \n", noise_pct[2], "% noise"),
#          x = "",
#          y = "") + 
#   #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
#   coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
# 
# 
# g3.8 <- ggplot(data = tibble(x.sim = sim_band8[3, , 1], y.sim = sim_band8[3, , 2])) + 
#   geom_point(aes(x.sim, y.sim), color = color) + 
#   labs(title = paste("8 bands \n", noise_pct[3], "% noise"),
#          x = "",
#          y = "") + 
#   #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
#   coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
# 
# 
# g4.8 <- ggplot(data = tibble(x.sim = sim_band8[4, , 1], y.sim = sim_band8[4, , 2])) + 
#   geom_point(aes(x.sim, y.sim), color = color) + 
#   labs(title = paste("8 bands \n", noise_pct[4], "% noise"),
#          x = "",
#          y = "") + 
#   #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
#   coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))


# 6 bands

g1.6 <- ggplot(data = tibble(x.sim = sim_band6[1, , 1], y.sim = sim_band6[1, , 2],
                             color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
    labs(title = paste("6 bands \n", noise_pct[1], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
  #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g2.6 <- ggplot(data = tibble(x.sim = sim_band6[2, , 1], y.sim = sim_band6[2, , 2],
                             color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("6 bands \n", noise_pct[2], "% noise"),
         x = "",
         y = "") + 
  #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))


g3.6 <- ggplot(data = tibble(x.sim = sim_band6[3, , 1], y.sim = sim_band6[3, , 2],
                             color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("6 bands \n", noise_pct[3], "% noise"),
         x = "",
         y = "") + 
  #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))


g4.6 <- ggplot(data = tibble(x.sim = sim_band6[4, , 1], y.sim = sim_band6[4, , 2],
                             color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("6 bands \n", noise_pct[4], "% noise"),
         x = "",
         y = "") + 
  #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))


# 3 bands

g1.3 <- ggplot(data = tibble(x.sim = sim_band3[1, , 1], y.sim = sim_band3[1, , 2],
                             color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
    labs(title = paste("3 bands \n", noise_pct[1], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))
  #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g2.3 <- ggplot(data = tibble(x.sim = sim_band3[2, , 1], y.sim = sim_band3[2, , 2],
                             color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("3 bands \n", noise_pct[2], "% noise"),
         x = "",
         y = "") + 
  #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.7))
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

g3.3 <- ggplot(data = tibble(x.sim = sim_band3[3, , 1], y.sim = sim_band3[3, , 2],
                             color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("3 bands \n", noise_pct[3], "% noise"),
         x = "",
         y = "") + 
  #coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

g4.3 <- ggplot(data = tibble(x.sim = sim_band3[4, , 1], y.sim = sim_band3[4, , 2],
                             color = data_test2$color)) + 
  geom_point(aes(x.sim, y.sim, color = color)) + 
  labs(title = paste("3 bands \n", noise_pct[4], "% noise"),
         x = "",
         y = "") + 
  #coord_fixed(ratio = 1, xlim = c(-1.7, 1.5), ylim = c(-1.5, 1.5))
  coord_fixed(ratio = 1, xlim = c(-2, 2), ylim = c(-2, 2))

grid.arrange(g1.25, g2.25, g3.25, g4.25,
             g1.10, g2.10, g3.10, g4.10, nrow = 2, ncol = 4)

#grid.arrange(g1.9, g2.9, g3.9, g4.9,
#             g1.8, g2.8, g3.8, g4.8, nrow = 2, ncol = 4)

grid.arrange(g1.6, g2.6, g3.6, g4.6, 
             g1.3, g2.3, g3.3, g4.3, nrow = 2, ncol = 4)

# orientation keeps changing 
```



