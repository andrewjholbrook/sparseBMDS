---
title: "HMC & MH Comparison for BMDS"
author: "Ami Sheth"
date: "2022-09-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Libraries
```{r}
library(MASS)
library(truncnorm)
library(coda)
library(invgamma)
```

### Functions for BMDS log-likelihood

```{r}
SSR <- function(n, D_latent, D){
  SSR_val = 0
  for (i in 1:n){
    for (j in 1:i){
      SSR_val = SSR_val + (D[i, j] - D_latent[i, j])^2
    }
  }
  return(SSR_val)
}

sum_norm <- function(n, D_latent, sigma){
  logsum = 0
  for (i in 1:n){
    for (j in 1:i){
      stat = D_latent[i, j] / sqrt(sigma)
      logsum = logsum + log(pnorm(stat)) 
    }
  }
  return(logsum)
}

ll_latent <- function(sigma, D, latent){ 
  # latent variables (nxk), observed distance matrix D (nxn), sigma^2
  D_latent <- as.matrix(dist(latent, diag = TRUE, upper = TRUE))
  n <- dim(D_latent)[1]
  m <- n * (n - 1) / 2
  term1 <- (m / 2) * log(sigma)
  term2 <- (1 / (2 * sigma)) * SSR(n, D_latent, D)
  term3 <- sum_norm(n, D_latent, sigma)
  loglik <- -(term1 + term2 + term3)
  return(loglik)
}
```

### Target & Delta Function

```{r}
target <- function(sigma, theta) { # theta the latent variable; dims x 1 vector
  output <- ll_latent(sigma, D, latent = theta) + 
    # independent, standard Gaussian prior for theta
    sum(mvtnorm::dmvnorm(theta, log = TRUE)) + 
    # inverse-gamma prior for sigma
    dinvgamma(sigma, shape = 1, rate = 1, log = TRUE) 
  return(output)
}

delta <- function(n) {
  return(min(0.01, n^(-0.5)))
}
```

### Function for Hamiltonian Monte Carlo (HMC)

- adaptive HMC for sigma and latent variables 

```{r}
grad <- function(sigma, D, latent) {
  D_latent <- as.matrix(dist(latent, diag = TRUE, upper = TRUE))
  n <- dim(D_latent)[1]
  grad_ll <- matrix(0, nrow = n, ncol = 2)
  grad_2row <- array(0, dim = c(n, n, 2))
  
  for (i in 1:n){
    grad_1row <- matrix(0, nrow = n, ncol = 2)
    for (j in 1:i){
      if (i != j){
        stat <- D_latent[i, j] / sqrt(sigma) # sigma = sigma^2
        grad_1row[j, ] <- ((D_latent[i, j] - D[i, j]) / sigma + 
                             dnorm(stat) / (sqrt(sigma) * pnorm(stat))) * 
          ((latent[i, ] - latent[j, ])/ D_latent[i, j])
      }
    }
    grad_2row[i, , ] <- grad_1row
  }
  
  for (i in 1:n){
    if (i == 1){
        likegrad <- - colSums(grad_2row[, i, ])
        grad_ll[i, ] <- - likegrad - latent[i, ]
      } else if(i == 2){
        likegrad <- grad_2row[i, i - 1, ] - colSums(grad_2row[, i, ])
        grad_ll[i, ] <- - likegrad - latent[i, ]
      }
      else{
        likegrad <- colSums(grad_2row[i, 1:(i - 1), ]) - 
          colSums(grad_2row[, i, ])
        grad_ll[i, ] <- - likegrad - latent[i, ]
      }
  }
  return(grad_ll)
}  

########## joint latent and sigma inference ############

hmc_joint <- function(dims, maxIts, stepSize = 0.01, stepSizeSigma = 1, 
                      targetAccept = 0.65, targetAccept_Sigma = 0.5) {
  
  # initialization for latent variable
  chain <- array(0, dim = c(maxIts, n, dims))
  acceptances <- 0
  totalaccept <- rep(0, maxIts)
  SampCount <- 0
  SampBound <- 50   # current total samples before adapting radius
  
  # initialization for sigma
  sigma_chain <- rep(0, maxIts)
  totalaccept_Sigma <- rep(0, maxIts)
  acceptances_Sigma <- 0
  SampCount_Sigma <- 0
  
  L <- 20 # number of leapfrog steps
  
  # random starting point for latent variables and sigma
  chain[1, , ] <- mvtnorm::rmvnorm(n, mean = rep(0, dims), diag(dims))
  sigma_chain[1] <- 1
  currentU <- - target(sigma_chain[1], chain[1, , ]) # U(q0) = - log posterior 
  
  for (i in 2:maxIts) {
    ####### update for latent variables - HMC
    proposalState <- chain[i - 1, , ] # q0
    momentum <- mvtnorm::rmvnorm(n, mean = rep(0, dims), diag(dims)) # p0
    currentK <- sum(momentum^2)/2 # valid bc independence; dimension K(p0)
    
    # leapfrog steps - obtain qt and pt 
    momentum <- momentum + 
      0.5 * stepSize * grad(sigma_chain[i - 1], D, proposalState) # half-step 
    
    for (l in 1:L) { # full step for p and q unless end of trajectory
      proposalState <- proposalState + stepSize * momentum # qt
      if (l != L) momentum <- momentum + 
          stepSize * grad(sigma_chain[i - 1], D, proposalState)
    }

    momentum <- momentum + 
      0.5 * stepSize * grad(sigma_chain[i - 1], D, proposalState) # half-step
    
    # quantities for accept/reject
    proposedU = - target(sigma_chain[i - 1], proposalState) # U(qt)
    proposedK = sum(momentum^2)/2 # K(pt)
    u <- runif(1)
    
    if (log(u) < currentU - proposedU + currentK - proposedK) {
      chain[i, , ] <- proposalState # move pt to be p0 now
      currentU <- proposedU # update U(p0)
      totalaccept[i] <- 1
      acceptances <- acceptances + 1
    } else {
      chain[i, , ] <- chain[i - 1, , ] # keep p0 
    }
    
    ####### update for sigma - adaptive Metropolis 
    
    # proposal distribution for sigma
    sigmaStar <- rtruncnorm(1, a = 0, b = Inf, mean = sigma_chain[i - 1], 
                            sd = stepSizeSigma) 
    # comparing new and old sigma with current chain, not a symmetric proposal 
    logA2 <- target(sigmaStar, chain[i, , ]) + proposedU +  
      # target(sigma_chain[i - 1], chain[i, , ]) + 
      log(truncnorm::dtruncnorm(x = sigma_chain[i - 1], a = 0, 
                                    mean = sigmaStar, sd = stepSizeSigma)) - 
      log(truncnorm::dtruncnorm(x = sigmaStar, a = 0, 
                                    mean = sigma_chain[i - 1], sd = stepSizeSigma)) 
    
    u2 <- runif(1)
    if(log(u2) < logA2) {
      sigma_chain[i] <- sigmaStar
      totalaccept_Sigma[i] <- 1
      acceptances_Sigma <- acceptances_Sigma + 1
    } else {
      sigma_chain[i] <- sigma_chain[i - 1]
    }

    # adaptive stepsize for latent variables
    SampCount <- SampCount + 1
    
    if (SampCount == SampBound) { 
      acceptRatio <- acceptances / SampBound
      if (acceptRatio > targetAccept) {
        stepSize <- stepSize * (1 + delta(i - 1)) # increase stepsize 
      } else {
        stepSize <- stepSize * (1 - delta(i - 1)) # decrease stepsize
      }
      
      # reset Sampcount and Acceptances
      SampCount <- 0
      acceptances <- 0
    }
    
    # adaptive stepsize for sigma
    SampCount_Sigma <- SampCount_Sigma + 1
    
    if (SampCount_Sigma == SampBound) { 
      acceptRatio_Sigma <- acceptances_Sigma / SampBound
      if (acceptRatio_Sigma > targetAccept_Sigma) {
        stepSizeSigma <- stepSizeSigma * (1 + delta(i - 1)) # increase stepsize 
      } else {
        stepSizeSigma <- stepSizeSigma * (1 - delta(i - 1)) # decrease stepsize
      }
      
      # reset SampCount and Acceptances
      SampCount_Sigma <- 0
      acceptances_Sigma <- 0
    }
    
    if (i %% 100 == 0) cat("Iteration ", i, "\n","stepSize: ", stepSize, "\n",
                           "stepSizeSigma: ", stepSizeSigma, "\n") 
  }
  
  cat("Acceptance rate: ", sum(totalaccept)/(maxIts - 1), 
      "Acceptance rate sigma: ", sum(totalaccept_Sigma)/(maxIts - 1))

  return(list(sigma_chain, chain))
}
```

### Function for Metropolis-Hastings (MH)

- adaptive MH for sigma and latent variables

```{r}
adapt_metropolis <- function(dims, maxIts, stepSize = 0.01, stepSizeSigma = 1,
                             targetAccept = 0.65, targetAccept_Sigma = 0.5) {
  
  # create the chain 
  chain <- array(0, dim = c(maxIts, n, dims))
  sigma_chain <- rep(0, maxIts)
  
  # specify the first random value
  chain[1, , ] <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(dims))
  sigma_chain[1] <- 1 # runif(1, min = 0.01, max = 0.99) # pick large number 
  
  totalAccept <- rep(0, maxIts)
  acceptances <- 0 # total acceptances within adaptation run (<= SampBound)
  SampBound <- 50   # current total samples before adapting radius
  SampCount <- 0   # number of samples collected (adapt when = SampBound)
  
  totalAccept_Sigma <- rep(0, maxIts)
  acceptances_Sigma <- 0
  SampCount_Sigma <- 0
  
  for (s in 2:maxIts) {
    # proposal: normal dist
    thetaStar <- cbind(rnorm(n, mean = chain[s - 1, , 1], sd = stepSize), 
                       rnorm(n, mean = chain[s - 1, , 2], sd = stepSize))
    u <- runif(1)
    logA <- target(sigma_chain[s - 1], thetaStar) - 
      target(sigma_chain[s - 1], chain[s - 1, , ]) # target on log scale
    
    if(log(u) < logA) {
      chain[s, , ] <- thetaStar # ACCEPT!! # next iteration to thetaStar
      totalAccept[s] <- 1
      acceptances <- acceptances + 1 # acceptance counter
    } else {
      chain[s, , ] <- chain[s - 1, , ] # REJECT!! # next iteration = previous
    }
    
    # proposal distribution for sigma
    sigmaStar <- rtruncnorm(1, a = 0, b = Inf, mean = sigma_chain[s - 1], 
                            sd = stepSizeSigma) 
    # comparing new and old sigma with current chain, not a symmetric proposal 
    logA2 <- target(sigmaStar, chain[s, , ]) - 
      target(sigma_chain[s - 1], chain[s, , ]) + 
      log(truncnorm::dtruncnorm(x = sigma_chain[s - 1], a = 0, 
                                    mean = sigmaStar, sd = stepSizeSigma)) - 
      log(truncnorm::dtruncnorm(x = sigmaStar, a = 0, mean = sigma_chain[s - 1], 
                                sd = stepSizeSigma)) 
    
    u2 <- runif(1)
    if(log(u2) < logA2) {
      sigma_chain[s] <- sigmaStar
      totalAccept_Sigma[s] <- 1
      acceptances_Sigma <- acceptances_Sigma + 1
    } else {
      sigma_chain[s] <- sigma_chain[s - 1]
    }
    
    SampCount <- SampCount + 1
    SampCount_Sigma <- SampCount_Sigma + 1
    
    # tune: smaller proposal variance = more acceptances 
    if (SampCount == SampBound) { 
      acceptRatio <- acceptances / SampBound
      if (acceptRatio > targetAccept) {
        stepSize <- stepSize * (1 + delta(s - 1)) # increase stepSize 
      } else {
        stepSize <- stepSize * (1 - delta(s - 1)) # decrease stepSize
      }
      
      # reset Sampcount and Acceptances
      SampCount <- 0
      acceptances <- 0
    }
    
    if (SampCount_Sigma == SampBound) { 
      acceptRatio_Sigma <- acceptances_Sigma / SampBound
      if (acceptRatio_Sigma > targetAccept_Sigma) {
        stepSizeSigma <- stepSizeSigma * (1 + delta(s - 1)) # increase stepSize 
      } else {
        stepSizeSigma <- stepSizeSigma * (1 - delta(s - 1)) # decrease stepSize
      }
      
      # reset Sampcount and Acceptances
      SampCount_Sigma <- 0
      acceptances_Sigma <- 0
    }
    
    if (s %% 100 == 0) cat("Iteration ", s, "\n","stepSize: ", stepSize, "\n",
                           "stepSizeSigma: ", stepSizeSigma, "\n") 
  }
  
  cat("Acceptance rate: ", sum(totalAccept)/(maxIts - 1), 
      "Acceptance rate for sigma: ", sum(totalAccept_Sigma)/(maxIts - 1))
  
  return(list(sigma_chain, chain))
}
```

### Simulation

```{r}
set.seed(12345)
maxIts <- 100000
burnin <- 30000
dims <- 2
n <- 25
# dims = 2, n = 25
Z <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) 
D <- as.matrix(dist(Z, diag = TRUE, upper = TRUE))

stimejhmc <- proc.time()
joint_hmc_results <- hmc_joint(dims, maxIts, targetAccept_Sigma = 0.5, 
                               targetAccept = 0.65, stepSize = 0.01, 
                               stepSizeSigma = 1)
timejhmc <- proc.time() - stimejhmc

stimemh <- proc.time()
adapt_results <- adapt_metropolis(dims, maxIts, targetAccept_Sigma = 0.5, 
                                  targetAccept = 0.65, stepSize = 0.01, 
                                  stepSizeSigma = 1)
timemh <- proc.time() - stimemh
```

### Sanity Checks - Graphs of HMC Output

```{r}
# first latent variable, first dimension
plot(joint_hmc_results[[2]][-(1:burnin), 1, 1], type = "l") 
acf(joint_hmc_results[[2]][-(1:burnin), 1, 1])

# sigma
plot(joint_hmc_results[[1]][-(1:burnin)], type = "l")

# traceplot when target function evaluated at thetas 
target_chain_hmc <- c()
for (i in 1:maxIts){
  target_chain_hmc[i] <- target(joint_hmc_results[[1]][i], 
                                joint_hmc_results[[2]][i, , ])
}

plot(target_chain_hmc[-(1:burnin)], type = "l")
plot(density(target_chain_hmc[-(1:burnin)])) 
acf(target_chain_hmc[-(1:burnin)])

# traceplots for pairwise distances
dist_mat_hmc <- array(0, dim = c(maxIts, n, n))
for (i in 1:maxIts){
  dist_mat_hmc[i, , ] <- as.matrix(dist(joint_hmc_results[[2]][i, , ], 
                                         diag = TRUE, upper = TRUE))
}

par(mfrow=c(2,2))
plot(dist_mat_hmc[-(1:burnin), 1, 2], type = "l")
abline(h = D[1, 2], col = "red")
plot(dist_mat_hmc[-(1:burnin), 2, 10], type = "l")
abline(h = D[2, 10], col = "red")
plot(dist_mat_hmc[-(1:burnin), 25, 5], type = "l")
abline(h = D[25, 5], col = "red")
plot(dist_mat_hmc[-(1:burnin), 15, 7], type = "l")
abline(h = D[15, 7], col = "red") # more off than the others

par(mfrow=c(2,2))
acf(dist_mat_hmc[-(1:burnin), 1, 2])
acf(dist_mat_hmc[-(1:burnin), 2, 10])
acf(dist_mat_hmc[-(1:burnin), 25, 5])
acf(dist_mat_hmc[-(1:burnin), 15, 7])

par(mfrow=c(2,2))
plot(density(dist_mat_hmc[-(1:burnin), 1, 2]))
plot(density(dist_mat_hmc[-(1:burnin), 2, 10]))
plot(density(dist_mat_hmc[-(1:burnin), 25, 5]))
plot(density(dist_mat_hmc[-(1:burnin), 15, 7]))
```

### Sanity Checks - Graphs of MH Output

```{r}
# first latent variable, first dimension
plot(adapt_results[[2]][-(1:burnin), 1, 1], type = "l")
acf(adapt_results[[2]][-(1:burnin), 1, 1])

# sigma
plot(adapt_results[[1]][-(1:burnin)], type = "l") 

# traceplot when target function evaluated at thetas 
target_chain_mh <- c()
for (i in 1:maxIts){
  target_chain_mh[i] <- target(adapt_results[[1]][i], adapt_results[[2]][i, , ])
}

plot(target_chain_mh[-(1:burnin)], type = "l")
plot(density(target_chain_mh[-(1:burnin)])) 
acf(target_chain_mh[-(1:burnin)])

# traceplot for pairwise distances
dist_mat_mh <- array(0, dim = c(maxIts, 25, 25))
for (i in 1:maxIts){
  dist_mat_mh[i, , ] <- as.matrix(dist(adapt_results[[2]][i, , ], 
                                       diag = TRUE, upper = TRUE))
}

par(mfrow=c(2,2))
plot(dist_mat_mh[-(1:burnin), 1, 2], type = "l")
abline(h = D[1, 2], col = "red")
plot(dist_mat_mh[-(1:burnin), 2, 10], type = "l")
abline(h = D[2, 10], col = "red")
plot(dist_mat_mh[-(1:burnin), 25, 5], type = "l")
abline(h = D[25, 5], col = "red")
plot(dist_mat_mh[-(1:burnin), 15, 7], type = "l")
abline(h = D[15, 7], col = "red") # more off than the others

par(mfrow=c(2,2))
acf(dist_mat_mh[-(1:burnin), 1, 2])
acf(dist_mat_mh[-(1:burnin), 2, 10])
acf(dist_mat_mh[-(1:burnin), 25, 5])
acf(dist_mat_mh[-(1:burnin), 15, 7])

par(mfrow=c(2,2))
plot(density(dist_mat_mh[-(1:burnin), 1, 2]))
plot(density(dist_mat_mh[-(1:burnin), 2, 10]))
plot(density(dist_mat_mh[-(1:burnin), 25, 5]))
plot(density(dist_mat_mh[-(1:burnin), 15, 7]))
```

### Time Comparison and Efficiency 

```{r}
#### times
timejhmc
timemh

#### effective size

# latent variables
coda::effectiveSize(joint_hmc_results[[2]][-(1:burnin), 1:10, 1])
coda::effectiveSize(adapt_results[[2]][-(1:burnin), 1:10, 1])

# target chain
(estjhmc <- coda::effectiveSize(target_chain_hmc[-(1:burnin)]))
(estmh <- coda::effectiveSize(target_chain_mh[-(1:burnin)]))

# pairwise distance between x = 10 and x = 1...25
(esdjhmc <- coda::effectiveSize(dist_mat_hmc[-(1:burnin), 1:25, 10]))
(esdmh <- coda::effectiveSize(dist_mat_mh[-(1:burnin), 1:25, 10]))

#### efficiency 
(estjhmc/timejhmc[3]) / (estmh/timemh[3]) # target chain
(esdjhmc/timejhmc[3]) / (esdmh/timemh[3]) # pairwise distance 
```

