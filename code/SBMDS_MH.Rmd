---
title: "Sparse BMDS Log-likelihood for Metropolis-Hastings"
author: "Ami Sheth"
date: "2022-09-08"
output: html_document
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(Matrix)
library(mvtnorm)
library(MASS)
library(invgamma)
library(truncnorm)
library(tidyverse)
library(gridExtra)
```

## Simulation data

```{r}
set.seed(12345)
Z_ex <- mvrnorm(100, mu = c(0,0), Sigma = diag(c(1, 1)))
D_ex <- as.matrix(dist(Z_ex, diag = TRUE, upper = TRUE))
```

```{r}
n <- dim(D_ex)[1]
band <- matrix(NA, nrow = n - 1, ncol = 3)
for (i in 1: n - 1){
  band[i, 1] <- D_ex[i, i + 1]
  if (i < n - 1){
    band[i, 2] <- D_ex[i, i + 2]
  }
  if (i < n - 2){
    band[i, 3] <- D_ex[i, i + 3]
  }
}
band
```

```{r}
n <- dim(D_ex)[1]
band <- matrix(NA, nrow = n - 1, ncol = 3)
pad <- matrix(NA, nrow = n, ncol = 3)
band_pad <- cbind(D_ex, pad)

for (i in 1: n - 1){
  band[i, ] <- band_pad[i, i + 1:3]
}

band
```

## Sparse log-likelihood

1. if-statement method

```{r}
# sum_r <- function(D_latent, D, sigma){
#   n <- dim(D)[1]
#   band_latent <- matrix(NA, nrow = n - 1, ncol = 3)
#   band_obs <- matrix(NA, nrow = n - 1, ncol = 3)
#   
#   for (i in 1:(n - 1)){
#     band_latent[i, 1] <- D_latent[i, i + 1]
#     band_obs[i, 1] <- D[i, i + 1]
#     if (i < n - 1){
#       band_latent[i, 2] <- D_latent[i, i + 2]
#       band_obs[i, 2] <- D[i, i + 2]
#       }
#     if (i < n - 2){
#       band_latent[i, 3] <- D_latent[i, i + 3]
#       band_obs[i, 3] <- D[i, i + 3]
#     }
#   }
#   
#   SSR_val = (band_obs - band_latent)^2
#   stat = band_latent / sqrt(sigma)
#   logsum = log(pnorm(stat))
#   r = sum(SSR_val/(2 * sigma) + logsum, na.rm = TRUE)
#   return(r)
# }
```

2. padded with NAs, function of number of bands

```{r}
sum_r <- function(D_latent, D, sigma, band.no){
  n <- dim(D)[1]
  band_latent <- matrix(NA, nrow = n - 1, ncol = band.no)
  band_obs <- matrix(NA, nrow = n - 1, ncol = band.no)
  pad <- matrix(NA, nrow = n, ncol = band.no)
  D_latent_pad <- cbind(D_latent, pad)
  D_pad <- cbind(D, pad)
  
  for (i in 1:(n - 1)){
    band_latent[i, ] <- D_latent_pad[i, i + 1:band.no]
    band_obs[i, ] <- D_pad[i, i + 1:band.no]
  }
  
  SSR_val = (band_obs - band_latent)^2
  stat = band_latent / sqrt(sigma)
  logsum = log(pnorm(stat))
  r = sum(SSR_val/(2 * sigma) + logsum, na.rm = TRUE)
  return(r)
}
```


```{r}
s_bmds_ll <- function(sigma, D, latent, band.no){ 
  # latent variables (nxk), observed distance matrix D (nxn), sigma^2
  D_latent <- as.matrix(dist(latent, diag = TRUE, upper = TRUE))
  n <- dim(D_latent)[1]
  m <- n * band.no - band.no * (band.no + 1) / 2  
  term1 <- (m / 2) * log(sigma)
  #term2 <- sum_r(D_latent, D, sigma)
  term2 <- sum_r(D_latent, D, sigma, band.no)
  loglik <- -(term1 + term2)
  return(loglik)
}
```

#### sanity check 

```{r}
set.seed(12345)
Z_ex <- mvrnorm(100, mu = c(0,0), Sigma = diag(c(1, 1)))
Z_tilde <- mvrnorm(100, mu = c(0,0), Sigma = diag(c(1, 1))) + 0.1

D_ex <- as.matrix(dist(Z_ex, diag = TRUE, upper = TRUE))

s_bmds_ll(sigma = 0.3, D_ex, latent = Z_ex, band.no = 3)
s_bmds_ll(sigma = 0.3, D_ex, latent = Z_tilde, band.no = 3)

#s_bmds_ll(sigma = 0.3, D_ex, latent = Z_ex)
#s_bmds_ll(sigma = 0.3, D_ex, latent = Z_tilde)

# [1] 184.5232
# [1] -693.3126
```

## M-H with sparse likelihood

1. adaptive theta

```{r}
# target function is the log-posterior which is proportional to log-likelihood + log-priors
s_target <- function(theta, D) { # theta the latent variable; dims x 1 vector
  output <- s_bmds_ll(sigma = 0.008, D, latent = theta, band.no = 3) + 
    sum(mvtnorm::dmvnorm(theta, log = TRUE)) # independent, standard Gaussian prior for theta
  return(output)
}

delta <- function(n) {
  return( min(0.01, n^(-0.5)) )
}

s_adapt_metropolis <- function(dims, maxIts, D, 
                              targetAccept = 0.8, 
                              stepSize = 1) {
  
  # create the chain 
  chain <- array(0, dim = c(maxIts, n, dims))
  
  # specify the first random value
  chain[1, , ] <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(dims))
  
  totalAccept <- rep(0, maxIts)
  Acceptances = 0 # total acceptances within adaptation run (<= SampBound)
  SampBound = 50   # current total samples before adapting radius
  SampCount = 0   # number of samples collected (adapt when = SampBound)
  
  for (s in 2:maxIts) {
    
    thetaStar <- cbind(rnorm(n, mean = chain[s - 1, , 1], sd = stepSize), 
                       rnorm(n, mean = chain[s - 1, , 2], sd = stepSize))
    # smaller proposal variance = more acceptances 
    # proposal: normal dist
    u <- runif(1)
    # Metropolis, A = target(thetaStar)/target(previous iteration)
    logA <- s_target(thetaStar, D) - 
      s_target(chain[s - 1, , ], D) # target on log scale
    
    if(log(u) < logA) {
      chain[s, , ] <- thetaStar # ACCEPT !! # next iteration to thetastar
      totalAccept[s] <- 1
      Acceptances = Acceptances + 1 # acceptance counter
    } else {
      chain[s, , ] <- chain[s - 1, , ] # REJECT !! # next iteration stays at same iteration
    }
    
    SampCount <- SampCount + 1
    
    # tune
    if (SampCount == SampBound) { 
      AcceptRatio <- Acceptances / SampBound
      if (AcceptRatio > targetAccept) {
        stepSize <- stepSize * (1 + delta(s - 1)) # increase stepsize 
      } else {
        stepSize <- stepSize * (1 - delta(s - 1)) # decrease stepsize
      }
      
      # reset Sampcount and Acceptances
      SampCount <- 0
      Acceptances <- 0
    }
    
    if (s %% 100 == 0) cat("Iteration ", s, "\n","stepSize: ", stepSize, "\n") 
  }
  
  cat("Acceptance rate: ", sum(totalAccept)/(maxIts - 1))
  
  return(chain)
}
```

```{r}
set.seed(12345)
maxIts <- 1000
dims <- 2
n <- 25
Z <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
D.1 <- as.matrix(dist(Z, diag = TRUE, upper = TRUE)) # n x n matrix of distances

s_adapt_results <- s_adapt_metropolis(dims, maxIts, D = D.1, targetAccept = 0.65, 
                                      stepSize = 1)
```

2. adaptive sigma and theta
```{r}
# target function is the log-posterior which is proportional to log-likelihood + log-priors
s_target2 <- function(sigma, theta, band.no, D) { # theta the latent variable; dims x 1 vector
  output <- s_bmds_ll(sigma, D, latent = theta, band.no) + 
    sum(mvtnorm::dmvnorm(theta, log = TRUE)) + # independent, standard Gaussian prior for theta
    dinvgamma(sigma, shape = 1, rate = 1, log = TRUE) # inverse-gamma prior for sigma
  return(output)
}

delta <- function(n) {
  return( min(0.01, n^(-0.5)) )
}

s_adapt_metropolis2 <- function(dims, maxIts, D, band.no = 3,
                              targetAccept = 0.8, targetAccept_Sigma = 0.8, 
                              stepSize = 1, stepSizeSigma = 1) {
  
  # create the chain 
  n <- dim(D)[1]
  chain <- array(0, dim = c(maxIts, n, dims)) # matrix(0, maxIts, D) 
  sigma_chain <- rep(0, maxIts)
  
  # specify the first random value
  chain[1, , ] <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(dims))
  sigma_chain[1] <- 1 # runif(1, min = 0.01, max = 0.99) # pick large number 
  
  totalAccept <- rep(0, maxIts)
  totalAccept_Sigma <- rep(0, maxIts)
  Acceptances = 0 # total acceptances within adaptation run (<= SampBound)
  Acceptances_Sigma = 0
  SampBound = 50   # current total samples before adapting radius
  SampCount = 0   # number of samples collected (adapt when = SampBound)
  SampCount_Sigma = 0
  
  for (s in 2:maxIts) {
    
    thetaStar <- cbind(rnorm(n, mean = chain[s - 1, , 1], sd = stepSize), 
                       rnorm(n, mean = chain[s - 1, , 2], sd = stepSize))
    # smaller proposal variance = more acceptances 
    # proposal: normal dist
    u <- runif(1)
    # Metropolis, A = target(thetaStar)/target(previous iteration)
    logA <- s_target2(sigma_chain[s - 1], thetaStar, band.no, D) - 
      s_target2(sigma_chain[s - 1], chain[s - 1, , ], band.no, D) # target on log scale
    
    if(log(u) < logA) {
      chain[s, , ] <- thetaStar # ACCEPT !! # next iteration to thetastar
      totalAccept[s] <- 1
      Acceptances = Acceptances + 1 # acceptance counter
    } else {
      chain[s, , ] <- chain[s - 1, , ] # REJECT !! # next iteration stays at same iteration
    }
    
    # proposal distribution for sigma
    sigmaStar <- rtruncnorm(1, a = 0, b = Inf, mean = sigma_chain[s - 1], sd = stepSizeSigma) 
    
    # Metropolis, A2 = target(sigmaStar)/target(previous iteration)
    # comparing new and old sigma with current chain, no longer symmetric proposal 
    logA2 <- s_target2(sigmaStar, chain[s, , ], band.no, D) - 
      s_target2(sigma_chain[s - 1], chain[s, , ], band.no, D) + 
      log(truncnorm::dtruncnorm(x = sigma_chain[s - 1], a = 0, 
                                    mean = sigmaStar, sd = stepSizeSigma)) - 
      log(truncnorm::dtruncnorm(x = sigmaStar, a = 0, 
                                    mean = sigma_chain[s - 1], sd = stepSizeSigma)) 
    
    u2 <- runif(1)
    if(log(u2) < logA2) {
      sigma_chain[s] <- sigmaStar
      totalAccept_Sigma[s] <- 1
      Acceptances_Sigma <- Acceptances_Sigma + 1
    } else {
      sigma_chain[s] <- sigma_chain[s - 1]
    }
    
    SampCount <- SampCount + 1
    SampCount_Sigma <- SampCount_Sigma + 1
    
    # tune
    if (SampCount == SampBound) { 
      AcceptRatio <- Acceptances / SampBound
      if ( AcceptRatio > targetAccept ) {
        stepSize <- stepSize * (1 + delta(s - 1)) # increase stepsize 
      } else {
        stepSize <- stepSize * (1 - delta(s - 1)) # decrease stepsize
      }
      
      # reset Sampcount and Acceptances
      SampCount <- 0
      Acceptances <- 0
    }
    
    if (SampCount_Sigma == SampBound) { 
      AcceptRatio_Sigma <- Acceptances_Sigma / SampBound
      if (AcceptRatio_Sigma > targetAccept_Sigma) {
        stepSizeSigma <- stepSizeSigma * (1 + delta(s - 1)) # increase stepsize 
      } else {
        stepSizeSigma <- stepSizeSigma * (1 - delta(s - 1)) # decrease stepsize
      }
      
      # reset Sampcount and Acceptances
      SampCount_Sigma <- 0
      Acceptances_Sigma <- 0
    }
    
    if (s %% 100 == 0) cat("Iteration ", s, "\n","stepSize: ", stepSize, "\n",
                           "stepSizeSigma: ", stepSizeSigma, "\n") 
  }
  
  cat("Acceptance rate: ", sum(totalAccept)/(maxIts - 1), 
      "Acceptance rate for sigma: ", sum(totalAccept_Sigma)/(maxIts - 1))
  
  return(list(sigma_chain, chain))
}
```

```{r}
set.seed(12345)
maxIts <- 1000
dims <- 2
n <- 25
Z <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
D.1 <- as.matrix(dist(Z, diag = TRUE, upper = TRUE)) # n x n matrix of distances

s_adapt_results2 <- s_adapt_metropolis2(dims, maxIts, band.no = 3, D = D.1, 
                                        targetAccept = 0.65, 
                                        targetAccept_Sigma = 0.5,
                                        stepSize = 1, stepSizeSigma = 1)
```

1. graphs for (1)

```{r}
burnin <- 1
plot(s_adapt_results[-(1:burnin), 1, 1], type = "l") # first latent variable, first dimension

# traceplot when target function evaluated at thetas 
s_target_chain_mh <- c()
for (i in 1:maxIts){
  s_target_chain_mh[i] <- s_target(s_adapt_results[i, , ], D = D.1)
}

plot(s_target_chain_mh[-(1:burnin)], type = "l")
#abline(h = target(Z), col = "red")
plot(density(s_target_chain_mh[-(1:burnin)])) 
acf(s_target_chain_mh[-(1:burnin)])
coda::effectiveSize(s_target_chain_mh[-(1:burnin)])

# traceplot for pairwise distances
s_dist_mat_mh <- array(0, dim = c(maxIts, 25, 25))
for (i in 1:maxIts){
  s_dist_mat_mh[i, , ] <- as.matrix(dist(s_adapt_results[i, , ], diag = TRUE, upper = TRUE))
}

par(mfrow=c(2,2))
plot(s_dist_mat_mh[-(1:burnin), 1, 2], type = "l")
abline(h = D.1[1, 2], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 3], type = "l")
abline(h = D.1[1, 3], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 4], type = "l")
abline(h = D.1[1, 4], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 5], type = "l")
abline(h = D.1[1, 5], col = "red")

plot(s_dist_mat_mh[-(1:burnin), 1, 6], type = "l")
abline(h = D.1[1, 6], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 7], type = "l")
abline(h = D.1[1, 7], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 8], type = "l")
abline(h = D.1[1, 8], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 1, 9], type = "l")
abline(h = D.1[1, 9], col = "red")

par(mfrow=c(2,2))
plot(s_dist_mat_mh[-(1:burnin), 2, 1], type = "l")
abline(h = D.1[2, 1], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 3], type = "l")
abline(h = D.1[2, 3], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 4], type = "l")
abline(h = D.1[2, 4], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 5], type = "l")
abline(h = D.1[2, 5], col = "red")

plot(s_dist_mat_mh[-(1:burnin), 2, 6], type = "l")
abline(h = D.1[2, 6], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 7], type = "l")
abline(h = D.1[2, 7], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 8], type = "l")
abline(h = D.1[2, 8], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 2, 9], type = "l")
abline(h = D.1[2, 9], col = "red")


plot(s_dist_mat_mh[-(1:burnin), 2, 10], type = "l")
abline(h = D.1[2, 10], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 25, 5], type = "l")
abline(h = D.1[25, 5], col = "red")
plot(s_dist_mat_mh[-(1:burnin), 15, 7], type = "l")
abline(h = D.1[15, 7], col = "red") # more off than the others

par(mfrow=c(2,2))
acf(s_dist_mat_mh[-(1:burnin), 1, 2])
acf(s_dist_mat_mh[-(1:burnin), 2, 10])
acf(s_dist_mat_mh[-(1:burnin), 25, 5])
acf(s_dist_mat_mh[-(1:burnin), 15, 7])

par(mfrow=c(2,2))
plot(density(s_dist_mat_mh[-(1:burnin), 1, 2]))
plot(density(s_dist_mat_mh[-(1:burnin), 2, 10]))
plot(density(s_dist_mat_mh[-(1:burnin), 25, 5]))
plot(density(s_dist_mat_mh[-(1:burnin), 15, 7]))

coda::effectiveSize(s_dist_mat_mh[-(1:burnin), 1:25, 10])
```

2. graphs for (2)
```{r}
burnin <- 1
plot(s_adapt_results2[[2]][-(1:burnin), 1, 1], type = "l") # first latent variable, first dimension
plot(s_adapt_results2[[1]][-(1:burnin)], type = "l") # sigmas

# traceplot when target function evaluated at thetas 
s_target_chain_mh2 <- c()
for (i in 1:maxIts){
  s_target_chain_mh2[i] <- s_target2(s_adapt_results2[[1]][i], s_adapt_results2[[2]][i, , ], band.no = 3, 
                                     D = D.1)
}

plot(s_target_chain_mh2[-(1:burnin)], type = "l")
#abline(h = target(Z), col = "red")
plot(density(s_target_chain_mh2[-(1:burnin)])) 
acf(s_target_chain_mh2[-(1:burnin)])
coda::effectiveSize(s_target_chain_mh2[-(1:burnin)])

# traceplot for pairwise distances
s_dist_mat_mh2 <- array(0, dim = c(maxIts, 25, 25))
for (i in 1:maxIts){
  s_dist_mat_mh2[i, , ] <- as.matrix(dist(s_adapt_results2[[2]][i, , ], diag = TRUE, upper = TRUE))
}
```

comparing across distances

```{r}
par(mfrow=c(2,2))
for (z in 1:n){
  for (y in 1:z){
    plot(s_dist_mat_mh2[-(1:burnin), z, y], type = "l", ylab = paste("Distance", z, "with", y))
    abline(h = D.1[z, y], col = "red")
  }
}
```


## capture MSE as a function of the number of bands

```{r}
set.seed(12345)
maxIts <- 100000
burnin <- 30000
dims <- 2
samp <- c(10, 15, 20, 25, 30)

mse_band <- matrix(NA, nrow = max(samp), ncol = length(samp))
for (r in 1:length(samp)){
  n <- samp[r]
  Z.sim <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
  D.sim <- as.matrix(dist(Z.sim, diag = TRUE, upper = TRUE)) # n x n matrix of distances
  for (s in 1:n){
    sim <- s_adapt_metropolis2(dims, maxIts, band.no = s, D = D.sim, targetAccept = 0.65,
                               targetAccept_Sigma = 0.5, stepSize = 1, stepSizeSigma = 1)
    error <- c()
    for (t in 1:maxIts){
      error[t] <- mean((as.matrix(dist(sim[[2]][t, , ], diag = TRUE, upper = TRUE)) - D.sim)^2)
    }
    mse_band[s, r] <- mean(error[-(1:burnin)])
  }
}
```

```{r}
for (r in 1:length(samp)){
  plot(mse_band[, r], ylab = "Mean Squared Error", xlab = "Band Number", 
       main = paste("Band Selection ( n = ", samp[r], ")"), 
       xlim = c(0, samp[r]))
}
```
```{r}
mse_band
```

```{r}
set.seed(12345)
maxIts <- 100000
dims <- 2
n <- 25
Z <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
D.1 <- as.matrix(dist(Z, diag = TRUE, upper = TRUE)) # n x n matrix of distances

s_adapt_results3 <- s_adapt_metropolis2(dims, maxIts, band.no = 6, D = D.1, targetAccept = 0.65, 
                                    targetAccept_Sigma = 0.5,
                                    stepSize = 1, stepSizeSigma = 1)
```

```{r}
burnin <- 30000
plot(s_adapt_results3[[2]][-(1:burnin), 1, 1], type = "l") # first latent variable, first dimension
plot(s_adapt_results3[[1]][-(1:burnin)], type = "l") # sigmas

# traceplot when target function evaluated at thetas 
s_target_chain_mh3 <- c()
for (i in 1:maxIts){
  s_target_chain_mh3[i] <- s_target2(s_adapt_results3[[1]][i], 
                                     s_adapt_results3[[2]][i, , ], band.no = 6, 
                                     D = D.1)
}

plot(s_target_chain_mh3[-(1:burnin)], type = "l")
#abline(h = target(Z), col = "red")
plot(density(s_target_chain_mh3[-(1:burnin)])) 
acf(s_target_chain_mh3[-(1:burnin)])
coda::effectiveSize(s_target_chain_mh3[-(1:burnin)])

# traceplot for pairwise distances
s_dist_mat_mh3 <- array(0, dim = c(maxIts, n, n))
for (i in 1:maxIts){
  s_dist_mat_mh3[i, , ] <- as.matrix(dist(s_adapt_results3[[2]][i, , ], diag = TRUE, upper = TRUE))
}
```
```{r}
par(mfrow=c(2,2))
for (z in 1:n){
  for (y in 1:z){
    plot(s_dist_mat_mh3[-(1:burnin), z, y], type = "l", ylab = paste("Distance", z, "with", y))
    abline(h = D.1[z, y], col = "red")
  }
}
```

### adding noise to observed distance matrix - error added to each element in distance matrix 

```{r}
set.seed(12345)
maxIts <- 100000
burnin <- 30000
dims <- 2
samp <- c(10, 15, 20, 25, 30)

#mse_band <- array(0, dim = c(samp, 2)) # row, column, number of the matrix
mse_band2 <- matrix(NA, nrow = max(samp), ncol = length(samp))
sigma.sim2 <- matrix(NA, nrow = max(samp), ncol = length(samp))
for (r in 1:length(samp)){
  n <- samp[r]
  Z.sim <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
  D.sim <- as.matrix(dist(Z.sim, diag = TRUE, upper = TRUE)) # n x n matrix of distances
  noise <- matrix(rexp(n^2, rate = 1), n, n) # mean = 1 # increasing magnitude of noise
  noise <- (noise + t(noise)) / 2
  diag(noise) <- 0
  D.noise <- noise + D.sim
  for (s in 1:n){
    sim <- s_adapt_metropolis2(dims, maxIts, band.no = s, targetAccept = 0.65, D = D.noise,
                               targetAccept_Sigma = 0.5, stepSize = 1, stepSizeSigma = 1)
    error <- c()
    for (t in 1:maxIts){
      error[t] <- mean((as.matrix(dist(sim[[2]][t, , ], diag = TRUE, upper = TRUE)) - D.noise)^2)
    }
    mse_band2[s, r] <- mean(error[-(1:burnin)])
    sigma.sim2[s, r] <- mean(sim[[1]][-(1:burnin)])
  }
}
```

```{r}
for (r in 1:length(samp)){
  plot(mse_band2[, r], ylab = "Mean Squared Error", xlab = "Band Number", 
       main = paste("Band Selection with noise ( n = ", samp[r], ")"), 
       xlim = c(0, samp[r]))
}
```
conclusion need more bands when adding error 

```{r}
for (r in 1:length(samp)){
  plot(sigma.sim2[, r], ylab = "Posterior Mean of Sigma", xlab = "Band Number", 
       main = paste("Band Selection with noise ( n = ", samp[r], ")"), 
       xlim = c(0, samp[r]))
}

sigma.sim2
```

larger error - mean of error = 2

```{r}
set.seed(12345)
maxIts <- 100000
burnin <- 30000
dims <- 2
samp <- c(10, 15, 20, 25, 30)

#mse_band <- array(0, dim = c(samp, 2)) # row, column, number of the matrix
mse_band3 <- matrix(NA, nrow = max(samp), ncol = length(samp))
sigma.sim3 <- matrix(NA, nrow = max(samp), ncol = length(samp))
for (r in 1:length(samp)){
  n <- samp[r]
  Z.sim <- mvtnorm::rmvnorm(n, mean = rep(0, dims), sigma = diag(c(1, 1))) # dims = 2, n = 25
  D.sim <- as.matrix(dist(Z.sim, diag = TRUE, upper = TRUE)) # n x n matrix of distances
  noise <- matrix(rexp(n^2, rate = 0.5), n, n) # mean = 1 # increasing magnitude of noise
  noise <- (noise + t(noise)) / 2
  diag(noise) <- 0
  D.noise <- noise + D.sim
  for (s in 1:n){
    sim <- s_adapt_metropolis2(dims, maxIts, band.no = s, targetAccept = 0.65, D = D.noise,
                               targetAccept_Sigma = 0.5, stepSize = 1, stepSizeSigma = 1)
    error <- c()
    for (t in 1:maxIts){
      error[t] <- mean((as.matrix(dist(sim[[2]][t, , ], diag = TRUE, upper = TRUE)) - D.noise)^2)
    }
    mse_band3[s, r] <- mean(error[-(1:burnin)])
    sigma.sim3[s, r] <- mean(sim[[1]][-(1:burnin)])
  }
}
```

### error graph

```{r}
sig_error <- function(noise){
  sig <- log(1 + noise/100)
  return(sqrt(sig))
}

# pct needs to be a vector
sim_errorpct <- function(pct, dims, size, maxIts, band.no, targetAccept, data,
                         targetAccept_Sigma, stepSize, stepSizeSigma){
  data_sim <- array(0, dim = c(length(pct), size, dims))
  for (i in 1:length(pct)){
    noise <- matrix(exp(rnorm(size^2, mean = 0, sd = sig_error(noise = pct[i]))), size, size)
    noise <- (noise + t(noise)) / 2
    diag(noise) <- 0
    D.noise <- noise * data
    sim <- s_adapt_metropolis2(dims, maxIts, band.no, targetAccept, D = D.noise,
                                  targetAccept_Sigma, stepSize, stepSizeSigma)
  
    data_sim[i, , ] <- sim[[2]][maxIts, , ]
  }
  return(data_sim)
}
```

data simulation
```{r}
x <- rep(seq(-1, 1, by = .5), 5)
y <- c(rep(1, 5), rep(-0.5, 5), rep(0, 5), rep(0.5, 5), rep(1, 5))
color <- rep(c("blue", "green", "yellow", "orange", "red"), 5)
data_test <- tibble(x, y, color)

dist_test <- as.matrix(dist(data_test[, 1:2], diag = TRUE, upper = TRUE))

# data_test
ggplot(data = data_test) + 
  geom_point(aes(x, y), color = color)
```

```{r}
set.seed(12345)
noise_pct <- c(0, 2, 5, 10)
sim_band25 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 25, 
                           targetAccept = 0.65, data = dist_test, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
set.seed(12345)
sim_band10 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 10, 
                           targetAccept = 0.65, data = dist_test, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
set.seed(12345)
sim_band6 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 6, 
                           targetAccept = 0.65, data = dist_test, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
set.seed(12345)
sim_band3 <- sim_errorpct(pct = noise_pct, dims = 2, size = 25, 
                           maxIts = 100000, band.no = 3, 
                           targetAccept = 0.65, data = dist_test, 
                           targetAccept_Sigma = 0.5, stepSize = 1, 
                           stepSizeSigma = 1)
```

```{r}
theme_update(plot.title = element_text(hjust = 0.5, size = rel(.75)))

# 25 bands 
g1.25 <- ggplot(data = tibble(x.sim = sim_band25[1, , 1], y.sim = sim_band25[1, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("25 bands \n", noise_pct[1], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g2.25 <- ggplot(data = tibble(x.sim = sim_band25[2, , 1], y.sim = sim_band25[2, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("25 bands \n", noise_pct[2], "% noise"),
         x = "",
         y = "") + 
coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g3.25 <- ggplot(data = tibble(x.sim = sim_band25[3, , 1], y.sim = sim_band25[3, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("25 bands \n", noise_pct[3], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g4.25 <- ggplot(data = tibble(x.sim = sim_band25[4, , 1], y.sim = sim_band25[4, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("25 bands \n", noise_pct[4], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

# 10 bands

g1.10 <- ggplot(data = tibble(x.sim = sim_band10[1, , 1], y.sim = sim_band10[1, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
    labs(title = paste("10 bands \n", noise_pct[1], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g2.10 <- ggplot(data = tibble(x.sim = sim_band10[2, , 1], y.sim = sim_band10[2, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("10 bands \n", noise_pct[2], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.7, 1.5), ylim = c(-1.5, 1.5))

g3.10 <- ggplot(data = tibble(x.sim = sim_band10[3, , 1], y.sim = sim_band10[3, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("10 bands \n", noise_pct[3], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g4.10 <- ggplot(data = tibble(x.sim = sim_band10[4, , 1], y.sim = sim_band10[4, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("10 bands \n", noise_pct[4], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.7))

# 6 bands

g1.6 <- ggplot(data = tibble(x.sim = sim_band6[1, , 1], y.sim = sim_band6[1, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
    labs(title = paste("6 bands \n", noise_pct[1], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g2.6 <- ggplot(data = tibble(x.sim = sim_band6[2, , 1], y.sim = sim_band6[2, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("6 bands \n", noise_pct[2], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g3.6 <- ggplot(data = tibble(x.sim = sim_band6[3, , 1], y.sim = sim_band6[3, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("6 bands \n", noise_pct[3], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g4.6 <- ggplot(data = tibble(x.sim = sim_band6[4, , 1], y.sim = sim_band6[4, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("6 bands \n", noise_pct[4], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

# 3 bands

g1.3 <- ggplot(data = tibble(x.sim = sim_band3[1, , 1], y.sim = sim_band3[1, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
    labs(title = paste("3 bands \n", noise_pct[1], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g2.3 <- ggplot(data = tibble(x.sim = sim_band3[2, , 1], y.sim = sim_band3[2, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("3 bands \n", noise_pct[2], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.7))

g3.3 <- ggplot(data = tibble(x.sim = sim_band3[3, , 1], y.sim = sim_band3[3, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("3 bands \n", noise_pct[3], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))

g4.3 <- ggplot(data = tibble(x.sim = sim_band3[4, , 1], y.sim = sim_band3[4, , 2])) + 
  geom_point(aes(x.sim, y.sim), color = color) + 
  labs(title = paste("3 bands \n", noise_pct[4], "% noise"),
         x = "",
         y = "") + 
  coord_fixed(ratio = 1, xlim = c(-1.7, 1.5), ylim = c(-1.5, 1.5))

grid.arrange(g1.25, g2.25, g3.25, g4.25,
             g1.10, g2.10, g3.10, g4.10, nrow = 2, ncol = 4)

grid.arrange(g1.6, g2.6, g3.6, g4.6, 
             g1.3, g2.3, g3.3, g4.3, nrow = 2, ncol = 4)

# orientation keeps changing 
```